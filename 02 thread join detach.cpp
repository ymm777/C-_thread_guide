//
#include "stdafx.h"
//#include<thread>
//#include<iostream>
//using namespace std;
//
////子线程函数
////void myprint()
////{
////	cout << "我的子线程开始执行了" << endl;
////	//
////	//
////	//
////	cout << "我的子线程执行结束了1" << endl;
////	cout << "我的子线程执行结束了2" << endl;
////	cout << "我的子线程执行结束了3" << endl;
////	cout << "我的子线程执行结束了4" << endl;
////	cout << "我的子线程执行结束了5" << endl;
////	cout << "我的子线程执行结束了6" << endl;
////	cout << "我的子线程执行结束了7" << endl;
////	cout << "我的子线程执行结束了8" << endl;
////	cout << "我的子线程执行结束了9" << endl;
////
////}
//
//class TA
//{
//public:
//	int &m_i;
//	TA(int &i) :m_i(i){
//		cout << "TA的构造函数被执行" << endl;
//	}
//
//	TA(const TA& t):m_i(t.m_i)
//	{
//		cout << "TA的拷贝构造函数被执行" << endl;
//		this->m_i = t.m_i;
//	}
//
//	~TA(){
//		cout << "~TA的析构函数被执行" << endl;
//	}
//	void operator()()
//	{
//		cout << "m_i1=" << this->m_i << endl;
//		cout << "m_i2=" << this->m_i << endl;
//		cout << "m_i3=" << this->m_i << endl;
//
//		//
//		//
//		//
//		cout << "m_i4=" << this->m_i << endl;
//	}
//};
//
//int main()
//{
//	//一、范例演示线程运行的开始和结束
//	//程序运行起来，生成一个进程，该进程所属的主线程开始自动运行；
//	//cout<<"I love China"<<endl;	//实际上这个是主线程在执行，主线程从main（）函数返回，则整个进程执行完毕；
//
//	//主线程从main()开始执行，那么我们自己创建的线程，也需要从一个函数开始运行（初始函数），一旦这个函数运行完毕，就代表着我们这个线程运行结束
//
//	//整个进程是否执行完毕的标志是 主线程是否执行完毕，如果主线程执行完毕，就代表整个进程执行完毕了。
//	  //此时，一般情况下：如果其他子线程还没有执行完毕，那么这些子线程就会被操作系统强行终止。
//	//所以，一般情况下，我们得到一个结论：如果大家想保持子线程（自己用代码创建的线程）的运行状态的话，那么大家要让主线程一直保存运行，不要让主线程运行完毕
//	//[这条规律有例外，老师后续会讲解这种例外，大家目前先这样理解和记忆]
//	//a）包含 一个头文件thread要包含进来
//	//b）初始函数要写
//	//c）main中开始写代码
//	//大家必须明确一点：有两个线程在跑，相当于整个程序的执行有两条线在同时走，所以可以同时干两个事，即使有一条线被堵住，不影响另一条线运行,这就是多线程
//	//(1.1)thread:是个标准库里的类
//	//(1.2)join():加入/汇合，说白了就是阻塞，阻塞主线程，让主线程等待子线程执行完毕，然后子线程和主线程汇合，然后主线程继续运行。
//	//如果主线程执行完毕了，但子线程没执行完毕，这种程序员是不合格的，写出来的程序是不稳定的。
//	//一个书写良好的程序，应该是主线程 等待子线程运行完毕后，自己才能最终退出。
//	//(1.3)detach():传统多线程程序要等待子线程执行完毕，然后自己在最后退出。
//	//detach：分离，也就是主线程不和子线程汇合了，你主线程执行你的，我子线程执行我的，你主线程不必等我子线程运行完毕，你可以先执行结束，这并不影响我子线程的执行
//	//为什么引入detach():我们创建了很多子线程，让主线程逐个等待子线程执行完毕，这种编程方法不太好，所以引入了detach
//	//一旦detach()之后，与这个主线程相关联的thread对象就会失去与这个主线程的关联，此时这个子线程就会驻留在后台运行（主线程与该子线程失去联系）
//	  //这个子线程就相当于被c++运行时库接管，当这个子线程执行完成后，由运行时库负责清理该线程相关的资源（守护线程）
//	//datach()使线程myprint失去自己的控制。
//	//(1.4)joinable(): 判断是否可以使用join()或者detach()的；返回true（可以使用join()或者detach())，否则不能。
//
//	//myprint可调用对象
//	//thread mytobj(myprint);		//(1)创建了线程，线程执行起点（入口）myprint()； (2)myprint线程开始执行
//	//
//	//if (mytobj.joinable())
//	//{
//	//	cout << "1.joinable==true" << endl;
//	//}
//	//else
//	//{
//	//	cout << "1.joinable==false" << endl;
//	//}
//
//	//阻塞主线程并等待myprint子线程执行完
//	//mytobj.join();		//主线程阻塞到这里等待myprint()执行完，当子线程执行完毕，这个join()就执行完毕，主线程将继续往下执行。
//
//	//mytobj.detach();		//一旦调用了detach(),就不能再用join(),否则系统会报告异常。
//
//	//if (mytobj.joinable())
//	//{
//	//	cout << "2.joinable==true" << endl;
//	//}
//	//else
//	//{
//	//	cout << "2.joinable==false" << endl;
//	//}
//
//	//二：其他创建线程的手法
//	//(2.1)用类对象（可调用对象），以及一个问题范例
//	//大家可能还有一个疑问：一旦调用了detach()，那我主线程执行结束了，我这里用的这个ta对象还在吗？（对象不在）
//	//这个对象实际上是被 复制 到线程中去；执行完主线程后，ta会被销毁，但是所复制的ta对象依然存在
//	  //所以，只要你这个TA对象里没有引用，没有指针，那么就不会产生问题；
//	int myi = 7;
//	TA ta(myi);
//	//TA tb(ta);
//	thread mytobj(ta);	//	ta可调用对象
//	mytobj.join(); 
//	//mytobj.detach();
//
//
//	//(2.2)用lambda表达式
//	//auto mylambda = []{
//	//	cout << "我的线程3执行开始了" << endl;
//	//	//...
//	//	cout << "我的线程3执行结束了" << endl;
//	//};
//
//	//thread mytobj(mylambda);
//	//mytobj.join();
//
//
//	cout << "I love China1" << endl;
//	cout << "I love China2" << endl;
//	cout << "I love China3" << endl;
//	cout << "I love China4" << endl;
//	cout << "I love China5" << endl;
//
//	//system("pause");
//	return 0;
//}